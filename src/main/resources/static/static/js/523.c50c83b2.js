"use strict";(self["webpackChunkroad_traffic_survey"]=self["webpackChunkroad_traffic_survey"]||[]).push([[523],{6523:function(e,t,r){r.d(t,{qf:function(){return i}});r(4224),r(1121),r(7133),r(560);var o=r(8962);function i(e,t=!1){const r=null!==e[0].index,i=new Set(Object.keys(e[0].attributes)),n=new Set(Object.keys(e[0].morphAttributes)),u={},l={},f=e[0].morphTargetsRelative,a=new o.u9r;let m=0;for(let o=0;o<e.length;++o){const s=e[o];let c=0;if(r!==(null!==s.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in s.attributes){if(!i.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===u[e]&&(u[e]=[]),u[e].push(s.attributes[e]),c++}if(c!==i.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". Make sure all geometries have the same number of attributes."),null;if(f!==s.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in s.morphAttributes){if(!n.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===l[e]&&(l[e]=[]),l[e].push(s.morphAttributes[e])}if(t){let e;if(r)e=s.index.count;else{if(void 0===s.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". The geometry must have either an index or a position attribute"),null;e=s.attributes.position.count}a.addGroup(m,e,o),m+=e}}if(r){let t=0;const r=[];for(let o=0;o<e.length;++o){const i=e[o].index;for(let e=0;e<i.count;++e)r.push(i.getX(e)+t);t+=e[o].attributes.position.count}a.setIndex(r)}for(const o in u){const e=s(u[o]);if(!e)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+o+" attribute."),null;a.setAttribute(o,e)}for(const o in l){const e=l[o][0].length;if(0===e)break;a.morphAttributes=a.morphAttributes||{},a.morphAttributes[o]=[];for(let t=0;t<e;++t){const e=[];for(let i=0;i<l[o].length;++i)e.push(l[o][i][t]);const r=s(e);if(!r)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+o+" morphAttribute."),null;a.morphAttributes[o].push(r)}}return a}function s(e){let t,r,i,s=0;for(let o=0;o<e.length;++o){const n=e[o];if(n.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===t&&(t=n.array.constructor),t!==n.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=n.itemSize),r!==n.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===i&&(i=n.normalized),i!==n.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;s+=n.array.length}const n=new t(s);let u=0;for(let o=0;o<e.length;++o)n.set(e[o].array,u),u+=e[o].array.length;return new o.TlE(n,r,i)}}}]);